import type { AlphaData } from "./contract"
import { EventEmitter, on } from "node:events"
import { LocalizedDisplayInfo, loadBoxed, ReplicaInfo } from "@reside/shared"
import { co, z } from "jazz-tools"
import { ContractEntity } from "./contract-entity"
import { GrantedPermission } from "./permissions"

export type ReplicaVersion = co.loaded<typeof ReplicaVersion>
export type Replica = co.loaded<typeof Replica>
export type ReplicaRequirement = co.loaded<typeof ReplicaRequirement>
export type GrantedPermissionSet = co.loaded<typeof GrantedPermissionSet>
export type ReplicaVersionStatus = z.infer<typeof ReplicaVersionStatus>

export const GrantedPermissionSet = co.map({
  /**
   * The resolved contract entity.
   */
  contract: ContractEntity,

  /**
   * The replicas this contract was resolved to.
   *
   * Can be empty if `optional` is true and no suitable replicas found.
   * Can contain more than one replica if `multiple` is true.
   */
  get replicas() {
    return co.list(Replica)
  },

  /**
   * The permissions granted to the replica for this contract.
   */
  permissions: co.list(GrantedPermission),
})

export const ReplicaRequirement = co.map({
  /**
   * The resolved contract entity.
   */
  contract: ContractEntity,

  /**
   * The replicas this contract was resolved to.
   *
   * Can be empty if `optional` is true and no suitable replicas found.
   * Can contain more than one replica if `multiple` is true.
   */
  get replicas() {
    return co.list(Replica)
  },

  /**
   * The permissions granted to the replica for this contract.
   */
  permissions: co.list(GrantedPermission),

  /**
   * Whether the requirement is optional.
   */
  optional: z.boolean(),

  /**
   * Wether the requirement is multiple.
   */
  multiple: z.boolean(),
})

export const ReplicaManagementBlock = co.map({
  /**
   * Whether the replica is enabled and should be running.
   *
   * Authorized accounts can update this field to enable or disable the replica.
   */
  enabled: z.boolean(),
})

export const ReplicaVersionStatus = z.enum([
  /**
   * The replica version's workload is not found in the cluster or its status cannot be determined.
   */
  "unknown",

  /**
   * The replica version is created and is being started.
   */
  "starting",

  /**
   * The replica version is running normally.
   */
  "running",

  /**
   * The replica version is running but with some degraded functionality.
   *
   * Only applicable to long-running replicas.
   */
  "degraded",

  /**
   * The replica version is running but will soon be stopped when new version is ready.
   *
   * Only applicable to long-running replicas.
   */
  "running-outdated",

  /**
   * The replica version was completed and is not running.
   *
   * Only applicable to oneshot replicas.
   */
  "completed",

  /**
   * The replica version is being stopped.
   */
  "stopping",

  /**
   * The replica version is stopped and is not running.
   */
  "stopped",

  /**
   * The replica version has encountered an error and is not running.
   */
  "error",
])

export const Replica = co.map({
  /**
   * The registration number of the replica.
   *
   * It is sequentially assigned when the replica is first appearing in the cluster.
   *
   * The first three replicas are always the same in every Reside cluster:
   *
   * 0. `seed`: The Seed Replica, responsible for bootstrapping the cluster.
   * 1. `alpha`: The Alpha Replica, responsible for orchestrating other replicas.
   * 2. `kubernetes-sentinel`: The Kubernetes Sentinel Replica, responsible for managing Kubernetes objects.
   *
   * All other replicas are assigned IDs starting from `3` in the order they first appear in the cluster.
   */
  id: z.number(),

  /**
   * The technical name of the replica scoped to this cluster.
   *
   * In most cases, it matches the `name` field in `info`.
   * But when multiple non-exclusive replicas of the same identity are running in the cluster, this field will be unique for each replica and generated by appending a suffix `-1`, `-2`, etc. to its technical name.
   * This name can also be set explicitly when creating the replica.
   * The same behaviour applies to exclusive replicas when there is a name conflict during their first registration in the cluster.
   */
  name: z.string(),

  /**
   * The fully qualified name of the container image used by the replica without the tag.
   *
   * For example: `ghcr.io/exeteres/reside/alpha`.
   *
   * This field gives the unique identity to the replica.
   *
   * Since the identity does not include the tag, updating the replica to a new version (e.g., `ghcr.io/exeteres/reside/alpha:v1.0.0` to `ghcr.io/exeteres/reside/alpha:v1.1.0`) does not change its identity.
   *
   * The identity also serves as some kind of verification: it is assumed that only trusted parties can push images to the given container registry/repository.
   *
   * This field must be unique across all exclusive replicas in the cluster, but can be shared by non-exclusive replicas.
   */
  identity: z.string(),

  /**
   * The static information about the replica extracted from its container image metadata.
   *
   * Cannot be changed after the replica first appears in the cluster.
   * If newer version of the replica provides different info, it will be rejected.
   */
  info: ReplicaInfo,

  /**
   * The service account of the replica that owns its data.
   */
  account: co.account(),

  /**
   * The special block writable by accounts with "replica:manage:all" permission.
   */
  management: ReplicaManagementBlock,

  /**
   * The current version of the replica deployed in the cluster.
   */
  get currentVersion() {
    return ReplicaVersion.optional()
  },

  /**
   * The historical versions of the replica deployed in the cluster.
   */
  get versions() {
    return co.list(ReplicaVersion)
  },
})

export const ReplicaVersion = co.map({
  /**
   * The registration number of the replica version.
   *
   * It is sequentially assigned when the replica version is first deployed in the cluster.
   *
   * This ID is scoped to the replica, multiple replicas can have the same version IDs.
   */
  id: z.number(),

  /**
   * The runtime status of the replica version.
   *
   * Determined by the workload state in the cluster.
   */
  status: ReplicaVersionStatus,

  /**
   * The replica this version corresponds to.
   */
  get replica() {
    return Replica
  },

  /**
   * The image requested when loading this replica version.
   *
   * Will not be used to deployment, just for record-keeping.
   *
   * The actual deployable image is calculated as `<identity>@<digest>` and never uses tags.
   */
  image: z.string(),

  /**
   * The resolved image digest which will be used for deployment.
   *
   * This ensures immutability and disallows "moving" tags.
   */
  digest: z.string(),

  /**
   * The display information of the replica version per locale.
   *
   * The key is a BCP 47 language tag (e.g., "en", "fr", "de", "en-US").
   */
  displayInfo: LocalizedDisplayInfo,

  /**
   * The resolved contracts used by the replica.
   *
   * Points to the up-to-date contracts provided by the current version of the replica.
   */
  get requirements() {
    return co.record(z.string(), ReplicaRequirement)
  },

  /**
   * The contracts implemented by the replica.
   *
   * Points to the up-to-date contract entities provided by the current version of the replica.
   */
  implementations: co.record(z.string(), ContractEntity),
})

/**
 * Returns the replica with the given ID, or null if not found or access is denied.
 *
 * @param alphaData The alpha contract data.
 * @param id The ID of the replica to retrieve.
 */
export async function getReplicaById(alphaData: AlphaData, id: number): Promise<Replica | null> {
  return await loadBoxed(
    Replica,
    `replica.by-id.${id}`,
    alphaData.$jazz.owner.$jazz.id,
    alphaData.$jazz.loadedAs,
  )
}

/**
 * Returns the replica with the given name, or null if not found or access is denied.
 *
 * @param alphaData The alpha contract data.
 * @param name The name of the replica to retrieve.
 */
export async function getReplicaByName(
  alphaData: AlphaData,
  name: string,
): Promise<Replica | null> {
  return await loadBoxed(
    Replica,
    `replica.by-name.${name}`,
    alphaData.$jazz.owner.$jazz.id,
    alphaData.$jazz.loadedAs,
  )
}

/**
 * Returns the array of replicas with the given identity or empty list if none found or access is denied.
 *
 * @param alphaData The alpha contract data.
 * @param identity The identity of the replicas to retrieve.
 */
export async function getReplicasByIdentity(
  alphaData: AlphaData,
  identity: string,
): Promise<Replica[]> {
  const replicas = await co
    .list(Replica)
    .loadUnique(`replica.by-identity.${identity}`, alphaData.$jazz.owner.$jazz.id, {
      loadAs: alphaData.$jazz.loadedAs,
      resolve: { $each: true },
    })

  return replicas.$isLoaded ? Array.from(replicas.values()) : []
}

/**
 * Returns the array of replicas implementing the given contract or empty list if none found or access is denied.
 *
 * @param alphaData The alpha contract data.
 * @param contractId The ID of the contract.
 */
export async function getReplicasImplementingContract(
  alphaData: AlphaData,
  contractId: number,
): Promise<Replica[]> {
  const replicas = await co
    .list(Replica)
    .loadUnique(`replica.by-contract.${contractId}`, alphaData.$jazz.owner.$jazz.id, {
      loadAs: alphaData.$jazz.loadedAs,
      resolve: { $each: true },
    })

  return replicas.$isLoaded ? Array.from(replicas.values()) : []
}

type ReplicaStabilizationResolve = {
  currentVersion: true
  versions: { $each: true }
}

type ReplicaStatusResolve = {
  currentVersion: true
}

type LoadedReplicaForStabilization = co.loaded<typeof Replica, ReplicaStabilizationResolve>
type LoadedReplicaForStatus = co.loaded<typeof Replica, ReplicaStatusResolve>

const NON_FINAL_VERSION_STATUSES: Array<ReplicaVersion["status"]> = [
  "running",
  "running-outdated",
  "starting",
  "stopping",
  "degraded",
]

export function isReplicaStable(replica: LoadedReplicaForStabilization): boolean {
  const currentVersion = replica.currentVersion
  if (!currentVersion) {
    return false
  }

  if (!replica.versions.length) {
    return false
  }

  if (currentVersion.status !== "running") {
    return false
  }

  return replica.versions
    .filter(version => version.id !== currentVersion.id)
    .every(version => !NON_FINAL_VERSION_STATUSES.includes(version.status))
}

export async function* waitForReplicaStabilization(
  alphaData: AlphaData,
  replicaId: number,
): AsyncIterable<LoadedReplicaForStabilization> {
  const replica = await getReplicaById(alphaData, replicaId)
  if (!replica) {
    throw new Error(`Replica with ID ${replicaId} not found`)
  }

  const loadedReplica = await replica.$jazz.ensureLoaded({
    resolve: {
      currentVersion: true,
      versions: { $each: true },
    },
  })

  if (isReplicaStable(loadedReplica)) {
    yield loadedReplica
    return
  }

  const ee = new EventEmitter<{ update: [LoadedReplicaForStabilization] }>()

  const unsubscribe = loadedReplica.$jazz.subscribe(replica => {
    ee.emit("update", replica)
  })

  for await (const [updatedReplica] of on(ee, "update") as AsyncIterable<
    [LoadedReplicaForStabilization]
  >) {
    yield updatedReplica

    if (isReplicaStable(updatedReplica)) {
      unsubscribe()
      return
    }
  }
}

export async function* waitForReplicaStatus(
  alphaData: AlphaData,
  replicaId: number,
  desiredStatus: ReplicaVersionStatus,
): AsyncIterable<LoadedReplicaForStatus> {
  const replica = await getReplicaById(alphaData, replicaId)
  if (!replica) {
    throw new Error(`Replica with ID ${replicaId} not found`)
  }

  const loadedReplica = await replica.$jazz.ensureLoaded({
    resolve: {
      currentVersion: true,
    },
  })

  if (loadedReplica.currentVersion?.status === desiredStatus) {
    yield loadedReplica
    return
  }

  const ee = new EventEmitter<{ update: [LoadedReplicaForStatus] }>()

  const unsubscribe = loadedReplica.$jazz.subscribe(replica => {
    ee.emit("update", replica)
  })

  for await (const [updatedReplica] of on(ee, "update") as AsyncIterable<
    [LoadedReplicaForStatus]
  >) {
    yield updatedReplica

    if (updatedReplica.currentVersion?.status === desiredStatus) {
      unsubscribe()
      return
    }
  }
}
