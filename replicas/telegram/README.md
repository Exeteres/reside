# Телеграмная Реплика

[Назад к списку реплик](/replicas/README.md)

<table>
<tr>
<td valign="top">

Эта реплика предоставляет другим репликам возможность взаимодействовать с пользователями через Telegram.

</td>
<td>

<img width="300" src="REPLICA.png" alt="Telegram Replica"/>

</td>
</tr>
</table>

## Принцип работы

Каждая реплика, которая хочет обрабатывать события из Telegram, должна зарегистрировать в Телеграмной Реплике свой обработчик с помощью хелпера `defineHandler` из пакета `@contracts/telegram.v1`. В коде [Глупой Реплики](/replicas/silly/README.md) есть [пример](/replicas/silly/src/handler.ts) того, как это сделать.

При запуске реплики-потребителя, хелпер помечает обработчик как активный. Когда Телеграмная Реплика получает событие из Telegram, она поочередно запрашивает каждый активный обработчик, передавая ему событие, до тех пор, пока один из обработчиков не вернет `handled: true`. Если обработчик не отвечает по таймауту или падает с ошибкой, Телеграмная Реплика логирует ошибку и переходит к следующему обработчику. Если ни один обработчик не смог обработать событие, оно игнорируется.

Для взаимодействия с обработчиками Телеграмная Реплика использует RPC-вызовы. Для этого, каждая реплика-потребитель должна реализовывать контракт `@contracts/telegram-handler.v1` и его метод `handleUpdate`.
При этом явной статической зависимости от этого контракта (и реализующих его реплик) у Телеграмной Реплике нет, она создает прокси для вызова динамически. В будущем такое поведение будет как-то декларироваться, потому что иначе будет невозможно введение сетевых политик.

## Обработка событий

В качестве библиотеки для взаимодействия с Telegram используется [grammy](https://grammy.dev/). Ее использует как сама Телеграмная Реплика, так и реплики-потребители. Благодаря хелперу, реплики могут использовать весь функционал grammy для обработки событий из Telegram. Они могут вешать любые обработчики на `composer` и использовать любые свойства контекста.

Но стоит помнить, что у каждой реплики-потребителя будет свой собственный контекст, который не будет передаваться между репликами. Более того, любые попытки установить блокировки (включая работу с сессиями) на этот контекст потенциально опасны, потому что существует вероятность, что из-за сетевой ошибки Телеграмная Реплика может переотправить сообщение другому обработчику. Для хранения состояния рекомендуется использовать объекты Jazz, привязанные к пользователю или чату.

Также стоит отметить, что реплики-потребители не имеют прямого доступа к API Telegram. Они также не видят токен бота. Тем не менее, любые вызовы `ctx.` и `ctx.api.` будут корректно работать, потому что хелпер позаботился о том, чтобы эти вызовы проксировались через Телеграмную Реплику.

## Реалм, пользователи и имперсонация

Телеграмная Реплика использует функционал [реалмов](/replicas/user-manager/README.md#реалмы) из [Пользовательской Реплики](/replicas/user-manager/README.md), чтобы управлять пользователями Telegram, с которыми она взаимодействует. Она отслеживает объекты `TelegramUser`, в которых хранится как информация о самом пользователе Telegram, так и связь с объектом `User` из Пользовательской Реплики. При первом взаимодействии с новым пользователем Телеграмная Реплика создает для него управляемого пользователя в реалме `telegram`. На этих пользователей распространяются все возможности Пользовательской Реплики, включая управление разрешениями.

В свою очередь, потребители Телеграмной Реплики могут обратиться к этим пользователям через `ctx.user`. Они также могут использовать функционал [имперсонации](/replicas/user-manager/README.md#имперсонация) для выполнения действий от имени пользователей и их разрешениями. [Пример](/replicas/alpha-secretary/src/composer.ts) такого использования есть в коде [Секретаря Альфа-Реплики](/replicas/alpha-secretary/README.md), и, в целом, в коде любых таких секретарей.
