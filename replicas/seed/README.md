# Первоначальная Реплика

[Назад к списку реплик](/replicas/README.md)

<table>
<tr>
<td valign="top">

Создает кластер ReSide, чтобы дать жизнь другим репликам.

</td>
<td>

<img width="300" src="REPLICA.png" alt="Seed Replica"/>

</td>
</tr>
</table>

## Развертывание

Если вы по каким-то неведомым причинам захотите запустить свой кластер ReSide,
то этот раздел для вас.

Вам понадобится:

- Kubernetes-кластер
- kubectl, настроенный на работу с этим кластером
- Ingress-контроллер
- Опционально: Cert Manager с ClusterIssuer для автоматического получения TLS-сертификатов

Есть два способа развернуть кластер ReSide:

### С помощью Reside CLI

Самый простой способ - использовать Reside CLI.
Но чтобы поставить его, вам придется склонировать этот репозиторий и зайти в `devenv shell`. Либо перейти в папку `apps/cli` и использовать `bun src/main.ts`.

Сначала нужно создать локальный аккаут Jazz, который будет использоваться для управления кластером:

```bash
reside account create {name}
```

Его приватный ключ будет зашифрован с помощью вашего вашей операционной системы, и записан в файле `.config/reside/config.yaml`.

Для создания кластера используйте команду:

```bash
reside cluster bootstrap --endpoint {domain}
```

Где `{domain}` - домен, по которому будет доступен сервер Jazz извне.

Можно также явно указать в каком неймспейсе и контексте kubectl создавать кластер:

```bash
reside cluster bootstrap --endpoint {domain} --namespace {namespace} --kube-context {context}
```

Есть также ряд опций для автоматического создания локального Kubernetes-кластера с помощью Kind, смотрите `reside cluster bootstrap --help` для подробностей.

Главный плюс такого способа в том, что после создания кластера, Reside CLI автоматически добавит его в ваш локальный конфиг и запросит права суперадминистратора для вашего аккаунта. После этого вы сможете сразу же загружать в кластер новые реплики.

### С помощью манифеста Kubernetes

Этот способ менее удобен, но зато позволяет лучше контролировать процесс развертывания.

Для запуска Первоначальной Реплики следует применить манифест [`seed.example.yaml`](/replicas/seed/manifests/seed.example.yaml) в нужном неймспейсе.
В нем также надо заполнить некоторые плейсхолдеры, а именно:

- `RESIDE_BOOTSTRAP_DOMAIN` - домен, по которому будет доступен сервер Jazz извне;
- `RESIDE_BOOTSTRAP_CLUSTER_ISSUER` - имя ClusterIssuer в кластере Kubernetes, который будет использоваться для получения TLS-сертификатов для Jazz.

Манифест с заполненными плейсхолдерами можно применить командой:

```bash
# создаем неймспейс для кластера
kubectl create namespace reside

# применяем манифест Первоначальной Реплики
kubectl apply -f seed.example.yaml -n reside
```

Далее, нужно дождаться завершения джобы и посмотреть логи, чтобы убедиться, что кластер создан успешно.

Правда все равно понадобится использовать Reside CLI, чтобы запросить права суперадминистратора для вашего аккаунта в новом кластере.
Сделать это можно командой:

```bash
# Добавить кластер в локальный конфиг
vim ~/.config/reside/config.yaml

# Запросить права суперадминистратора
reside cluster claim-super-admin-access
```

## Принцип работы

Самый базовый кластер ReSide представляет из себя неймспейс в Kubernetes, содержащий три основных компонента:

1. Сервер синхронизации данных [Jazz](https://jazz.tools/);
2. [Альфа-Реплику](/replicas/alpha/README.md), которая будет управлять всеми остальными репликами и запускать новые;
3. [Кубовую Реплику](/replicas/kubernetes-sentinel/README.md), которая монопольно управляет доступом к Kubernetes API.

После запуска всех трех компонентов, администратор может подключиться к серверу Jazz и начать создавать новые реплики в кластере с помощью Reside CLI.

Чтобы создать всю эту инфраструктуру и существует Первоначальная Реплика.
Она содержит в себе код обоих реплик и при запуске притворяется то одной, то другой, чтобы создать необходимые объекты и ресурсы в кластере.
Такой подход позволяет практически 1 в 1 воспроизвести логику запуска новой реплики в условиях, когда запускать ее еще некому.

Весь процесс запуска кластера можно разделить на следующие фазы:

### Фаза 1. Запуск Jazz и etcd

Jazz отвечает за взаимодействие реплик между собой и хранение их данных.
Первоначальная Реплика создает его StatefulSet, PVC и Service.

Аналогично создается StatefulSet и Service для etcd, который используется репликами для распределенных блокировок.

Дабы не усложнять логику запуска, на этом этапе не создаются никакие сетевые политики.
Ожидается, что поведение по умолчанию разрешает всем подам в неймспейсе взаимодействовать друг с другом.

### Фаза 2. Создание аккаунтов реплик в Jazz

Здесь уже начинается веселье.
Каждой реплике для работы нужен аккаунт в Jazz, а также доступный ему [RCB](/docs/2.REPLICAS.md#rcb).
Но создавать их некому, поэтому это делает Первоначальная Реплика.
RCB она создает от имени аккаунта Альфа-Реплики, дополнительно давая Кубовой Реплике доступ к ее RCB.

### Фаза 3. "Запуск" реплик

На самом деле никакой это не запуск.
Просто Первоначальная Реплика использует некоторые функции из кода Альфа-Реплики и Кубовой Реплики, чтобы инициализировать ее управляющие структуры.

В частности, вызывается функция `startReplica` для обех реплик, а переменные окружения заполняются так, словно это настоящие реплики. Внутри `startReplica` также запускается фоновый "поток" для синхронизации разрешений, благодаря чему Альфа-Реплика в дальнейшем сможет получить нужные доступы к Кубовой Реплике.

### Фаза 4. Выполнение процедуры загрузки реплик

Когда мы имеем нечто похожее на живых реплик, можно заставить их выполнить процедуру загрузки новых реплик.
Загружать они будут ... себя же. Причем, сначала будет загружена Кубовая Реплика, а затем Альфа-Реплика, потому что таков порядок зависимостей. Ах да, Первоначальная Реплика тоже будет загружена для истории, но она никогда не будет запущена еще раз.

> При этом в кластере ID Альфа-Реплики будет `1`, а Кубовой Реплики - `2`. Так сделано просто по приколу.

Для каждой реплики происходит следующее:

1. `createLoadRequest`: Создание запроса на загрузку с указанием реального докер-образа реплики;
2. `validateLoadRequest`: Валидация запроса на загрузку (загружаются метаданные образа и заполняются недостающие поля);
3. Одобрение запроса на загрузку (установка флага `approved` в `true`);
4. `createReplicaVersionFromLoadRequest`: Создание реплики на основе одобренного запроса на загрузку. При этом, поскольку у нас уже есть аккаунты и RCB, то они также передаются в эту функцию, чтобы не создавать новые.

### Фаза 5. Создание остальных Kubernetes-ресурсов

Секреты, деплойменты, сервисы и ингрессы реплик были созданы Альфа-Репликой (вернее, ее кодом) ранее.

На этом же этапе создаются остальные ресурсы, необходимые для работы кластера, а именно:

- Постоянный SA для Кубовой Реплики
- Роли и биндинги, необходимые для работы Кубовой Реплики
- дублируются манифесты StatefulSet, PVC, Service, Ingress для Jazz и etcd, созданные ранее

Затем вызывается метод `syncManagedObjects` для синхронизации состояния Кубовой Реплики и реальных ресурсов Kubernetes, но в режиме, который не будет изменять/удалять неопознанные ресурсы.

Без этого режима мы рискуем получить следующую ситуацию:

<details>
<img src="./assets/seed-issue.png" width="400"/>
</details>

После этого Первоначальная Реплика вызывает перезагрузку Кубовой Реплики, чтобы она вышла из щадящего режима и удалила неопознанные ресурсы, включая SA Первоначальной Реплики, ее роли, биндинги и ... ее саму. На этом процесс создания кластера завершается.
