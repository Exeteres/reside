# Реплики

1. [Обзор проекта](/docs/1.OVERVIEW.md)
2. Реплики
3. [Система разрешений](/docs/3.PERMISSIONS.md)
4. [Каталог реплик](/replicas/README.md)

---

Как уже было сказано в [обзорной части](/docs/1.OVERVIEW.md), основными "строительными блоками" кластера Reside являются реплики - автономные
одушевленные агенты. Теперь же пришло время рассмотреть их более подробно.

## Контракты

Чтобы реплики могли общаться друг с другом им необходимо договориться о протоколе взаимодействия.
Такими соглашениями в Reside являются контракты. Реплика может реализовывать один или несколько контрактов,
а также требовать от других реплик реализации определенных контрактов для взаимодействия с ними.
Таким образом также достигается инверсия управления - реплика не зависит от конкретных реплик, а только от контрактов, которые они реализуют.

Контракты в Reside определяются с помощью функции `defineContract` из пакета `@reside/shared`.
Этот пакет содержит все общие типы и утилиты, которые могут понадобиться как репликам, так и другим частям системы.
Каждый контракт лежит в своем пакете в скоупе `@contracts/`, например [`@contracts/alpha.v1`](/contracts/alpha.v1/src/contract.ts).

Определение контракта включает в себя:

- схему данных Jazz, доступную потребителям контракта;
- набор RPC-методов, которые могут быть вызваны потребителями контракта;
- набор разрешений, которые могут быть запрошены потребителями контракта;
- объект `displayInfo` с информацией, для отображения в пользовательском интерфейсе;
- поле `identity`.

Последний пункт заслуживает отдельного внимания.
Identity контракта - это полное имя докер-образа, включая URL его реестра и путь, но не включая тег или хеш.
Например: `ghcr.io/exeteres/reside/contracts/alpha.v1`. Identity позволяет с одной стороны обеспечить уникальность контракта,
а с другой стороны - аутентифицировать его, ведь только владелец реестра может публиковать образы с таким именем.

Образ каждого контракта имеет целых ... ноль слоев. Полезная же его часть находится в метаданных образа (labels), а
именно в поле `io.reside.manifest`. Оно содержит закодированную в base64 JSON-структуру, которая описывает контракт.

Еще все контракты имеют мажорную версию. Строго говоря, это просто соглашение, и технически это просто часть имени докер-образа.
Такое версионирование позволяет создавать новые несовместимые версии контрактов и реализовывать их параллельно со старыми.

## Реплики

С точки зрения системы, реплика - это тоже докер-образ, который также содержит поле `io.reside.manifest` в своих метаданных.
Она точно также имеет identity, но в отличие от контрактов, реплик не принято версионировать. Вместо этого
они просто реализуют все возможные контракты (и их версии) до тех пор, пока это будет кому-нибудь нужно.

Реплики лежат в скоупе `@replicas/`, например [`@replicas/alpha`](/replicas/alpha/src/main.ts).
Определение реплик выполняется с помощью функции `defineReplica` из пакета `@reside/shared`.

Определение реплики включает в себя:

- список реализуемых контрактов;
- список требуемых контрактов, а также статических разрешений, которые реплика запрашивает у них;
- объект `info`, описывающий некоторые инфраструктурные детали реплики;
- объект `displayInfo` с информацией, для отображения в пользовательском интерфейсе;
- `identity`.

Помимо определения, на основе которого формируется манифест реплики, в образе также должен находиться исходный код,
который реализует логику реплики. Reside CLI предоставляет команду `reside build`, которая автоматически собирает докер-образы реплики или контракта.
Она ожидает, что точка входа будет находиться в файле `src/main.ts`.

В этом файле также должен быть вызов функции `startReplica`, который запускает реплику,
подключает ее к системе и начинает обработку сообщений.

Объект `info` реплики содержит следующие поля:

- `name` - техническое имя реплики, например, `alpha`;
- `class` - класс реплики: `long-running` или `oneshot`;
- `exclusive` - если `true`, то в кластере может быть загружена только одна такая реплика; все последующие попытки запуска будут приводить к обновлению уже загруженной реплики;
- `scalable` - если `true`, то в кластере может быть временно запущено несколько экземпляров такой реплики при выполнении обновления; если `false`, то при обновлении сначала останавливается старая версия, а затем запускается новая; в остальном поведение реплики не меняется;

Стоит также отметить, что техническое имя реплики в кластере необязательно должно совпадать с `name` из ее `info`.
Оно будет использоваться по умолчанию, но при загрузке реплики в кластер можно указать любое другое имя.
И это придется сделать, если в кластере уже есть реплика с таким именем.
Это касается как обычных реплик, так и эксклюзивных.

Как уже было сказано в обзорной части, каждая реплика запускается в Kubernetes в своем собственном поде.
`long-running` реплики запускаются с помощью `Deployment`, а `oneshot` - с помощью `Job`.

Также каждая реплика имеет собственный аккаунт в Jazz, который используется для работы с данными и взаимодействия с другими репликами.
Секретные данные для доступа к этому аккаунту лежат в Kubernetes-секретах и подключаются к поду реплики в виде переменных окружения.

## RCB

Блок управления репликой, Replica Control Block, или RCB - это внутренняя структура данных в Reside, Jazz-объект,
который создается для каждой загруженной в кластер реплики. В нем хранится информация, необходимая реплики для запуска и работы,
а ID RCB она получает при запуске в качестве переменной окружения `RESIDE_CONTROL_BLOCK_ID`.

В RCB хранятся две основных вещи, необходимые реплике для работы:

- ссылки на объекты контрактов, которые она запрашивает у других реплик;
- список разрешений, которые ей предстоит выдать другим репликам.

RCB доступны на чтение и запись только тем репликам, для которых они созданы.

В следующем [разделе](/docs/3.PERMISSIONS.md) будет рассказано про систему разрешений, которая тесно связана с RCB.
