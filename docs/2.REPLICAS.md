# Реплики

1. [Обзор проекта](/docs/1.OVERVIEW.md)
2. Реплики
3. [Система разрешений](/docs/3.PERMISSIONS.md)
4. [Разработка реплик](/docs/4.DEVELOPMENT.md)
5. [Каталог реплик](/replicas/README.md)

---

Как уже было сказано в [обзорной части](/docs/1.OVERVIEW.md), основными "строительными блоками" кластера Reside являются реплики - автономные
одушевленные агенты. Теперь же пришло время рассмотреть их более подробно.

## Контракты

Чтобы реплики могли общаться друг с другом им необходимо договориться о протоколе взаимодействия.
Такими соглашениями в Reside являются контракты. Реплика может реализовывать один или несколько контрактов,
а также требовать от других реплик реализации определенных контрактов для взаимодействия с ними.
Таким образом также достигается инверсия управления - реплика не зависит от конкретных реплик, а только от контрактов, которые они реализуют.

Контракты в Reside определяются с помощью функции `defineContract` из пакета `@reside/shared`.
Этот пакет содержит все общие типы и утилиты, которые могут понадобиться как репликам, так и другим частям системы.
Каждый контракт лежит в своем пакете в скоупе `@contracts/`, например [`@contracts/alpha.v1`](/contracts/alpha.v1/src/contract.ts).

Определение контракта включает в себя:

- схему данных Jazz, доступную потребителям контракта;
- набор RPC-методов, которые могут быть вызваны потребителями контракта;
- набор разрешений, которые могут быть запрошены потребителями контракта;
- объект `displayInfo` с информацией, для отображения в пользовательском интерфейсе;
- поле `identity`.

Последний пункт заслуживает отдельного внимания.
Identity контракта - это полное имя докер-образа, включая URL его реестра и путь, но не включая тег или хеш.
Например: `ghcr.io/exeteres/reside/contracts/alpha.v1`. Identity позволяет с одной стороны обеспечить уникальность контракта,
а с другой стороны - аутентифицировать его, ведь только владелец реестра может публиковать образы с таким именем.

Образ каждого контракта имеет целых ... ноль слоев. Полезная же его часть находится в метаданных образа (labels), а
именно в поле `io.reside.manifest`. Оно содержит закодированную в base64 JSON-структуру, которая описывает контракт.

Еще все контракты имеют мажорную версию. Строго говоря, это просто соглашение, и технически это просто часть имени докер-образа.
Такое версионирование позволяет создавать новые несовместимые версии контрактов и реализовывать их параллельно со старыми.

## Реплики

С точки зрения системы, реплика - это тоже докер-образ, который также содержит поле `io.reside.manifest` в своих метаданных.
Она точно также имеет identity, но в отличие от контрактов, реплик не принято версионировать. Вместо этого
они просто реализуют все возможные контракты (и их версии) до тех пор, пока это будет кому-нибудь нужно.

Реплики лежат в скоупе `@replicas/`, например [`@replicas/alpha`](/replicas/alpha/src/main.ts).
Определение реплик выполняется с помощью функции `defineReplica` из пакета `@reside/shared`.

Определение реплики включает в себя:

- список реализуемых контрактов;
- список требуемых контрактов, а также статических разрешений, которые реплика запрашивает у них;
- объект `info`, описывающий некоторые инфраструктурные детали реплики;
- объект `displayInfo` с информацией, для отображения в пользовательском интерфейсе;
- `identity`.

Помимо определения, на основе которого формируется манифест реплики, в образе также должен находиться исходный код,
который реализует логику реплики. Reside CLI предоставляет команду `reside build`, которая автоматически собирает докер-образы реплики или контракта.
Она ожидает, что точка входа будет находиться в файле `src/main.ts`.

В этом файле также должен быть вызов функции `startReplica`, который запускает реплику,
подключает ее к системе и начинает обработку сообщений.

Объект `info` реплики содержит следующие поля:

- `name` - техническое имя реплики, например, `alpha`;
- `class` - класс реплики: `long-running` или `oneshot`;
- `exclusive` - если `true`, то в кластере может быть загружена только одна такая реплика; все последующие попытки запуска будут приводить к обновлению уже загруженной реплики;
- `scalable` - если `true`, то в кластере может быть временно запущено несколько экземпляров такой реплики при выполнении обновления; если `false`, то при обновлении сначала останавливается старая версия, а затем запускается новая; в остальном поведение реплики не меняется;

Стоит также отметить, что техническое имя реплики в кластере необязательно должно совпадать с `name` из ее `info`.
Оно будет использоваться по умолчанию, но при загрузке реплики в кластер можно указать любое другое имя.
И это придется сделать, если в кластере уже есть реплика с таким именем.
Это касается как обычных реплик, так и эксклюзивных.

Как уже было сказано в обзорной части, каждая реплика запускается в Kubernetes в своем собственном поде.
`long-running` реплики запускаются с помощью `Deployment`, а `oneshot` - с помощью `Job`.

Также каждая реплика имеет собственный аккаунт в Jazz, который используется для работы с данными и взаимодействия с другими репликами.
Секретные данные для доступа к этому аккаунту лежат в Kubernetes-секретах и подключаются к поду реплики в виде переменных окружения.

## RCB

Блок управления репликой, Replica Control Block, или RCB - это внутренняя структура данных в Reside, Jazz-объект,
который создается для каждой загруженной в кластер реплики. В нем хранится информация, необходимая реплики для запуска и работы,
а ID RCB она получает при запуске в качестве переменной окружения `RESIDE_CONTROL_BLOCK_ID`.

В RCB хранятся две основных вещи, необходимые реплике для работы:

- ссылки на объекты контрактов, которые она запрашивает у других реплик;
- список разрешений, которые ей предстоит выдать другим репликам.

RCB доступны на чтение и запись только тем репликам, для которых они созданы.

## RPC и взаимодействие между репликами

Реплики взаимодействуют друг с другом через RPC-вызовы, определенные в контрактах. Каждый контракт может объявлять набор методов, которые реплики-потребители могут вызывать у реплик-реализаторов.

RPC-методы объявляются в контракте с помощью поля `methods`. Каждый метод включает:

- `displayInfo` - информация для отображения в пользовательском интерфейсе;
- `definition` - фабричную функцию, которая принимает URL и workerId и возвращает определение запроса.

Пример объявления метода из контракта Альфа-Реплики:

```typescript
createLoadRequest: {
  displayInfo: {
    ru: {
      title: "Создание запроса на загрузку реплики",
      description: "Метод для создания запроса на загрузку новой реплики в кластер.",
    },
  },
  
  definition: (url, workerId) => {
    return defineMethod({
      url,
      workerId,
      request: { input: CreateLoadRequestInput },
      response: { schema: { loadRequest: ReplicaLoadRequest }, resolve: { loadRequest: true } },
    })
  },
},
```

Реплика-реализатор обрабатывает вызовы методов с помощью хендлеров, которые регистрируются при старте реплики:

```typescript
alpha.handleCreateLoadRequest(async ({ input }, madeBy) => {
  // обработка запроса
  return { loadRequest }
})
```

Реплика-потребитель вызывает методы через прокси-объекты, полученные из `requirements`:

```typescript
const { requirements: { alpha } } = await startReplica(MyReplica)

const result = await alpha.createLoadRequest({ input: { image: "..." } })
```

Все RPC-вызовы проходят через HTTP, а каждая реплика, реализующая хотя бы один метод, получает собственный Kubernetes Service и Ingress для приема запросов.

## Жизненный цикл реплики

### Запуск

При старте реплики выполняется следующая последовательность:

1. Загружается конфигурация из переменных окружения;
2. Авторизуется Jazz аккаунт реплики на основе секретных данных;
3. Загружается RCB реплики по ID из переменной окружения `RESIDE_CONTROL_BLOCK_ID`;
4. Подключаются все требуемые контракты из RCB;
5. Запускается фоновый процесс синхронизации разрешений (`reconcileControlBlockPermissions`);
6. Если реплика реализует RPC-методы, запускается HTTP-сервер для их обработки;
7. Выполняется пользовательский код инициализации реплики.

Все это делает функция `startReplica` из пакета `@reside/shared`, которая является точкой входа для любой реплики.

## Паттерн Секретаря

Секретарь (Secretary) - это специальный тип реплик, который предоставляет пользовательский интерфейс для взаимодействия с другими репликами через Telegram-бота. Примеры: [Секретарь Альфа-Реплики](/replicas/alpha-secretary/README.md) и [Секретарь Пользовательской Реплики](/replicas/user-manager-secretary/README.md).

Секретарь регистрирует обработчик в Телеграмной Реплике, использует имперсонацию пользователей и проксирует запросы к целевой реплике с разрешениями этих пользователей. Это позволяет секретарям не запрашивать широкие разрешения для себя, а использовать разрешения конкретных пользователей, что делает систему более безопасной.

Подробнее о реализации секретарей - в разделе [Паттерн Секретаря](/docs/4.DEVELOPMENT.md#паттерн-секретаря) руководства по разработке.

## RCB
