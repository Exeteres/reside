# Разработка реплик

1. [Обзор проекта](/docs/1.OVERVIEW.md)
2. [Реплики](/docs/2.REPLICAS.md)
3. [Система разрешений](/docs/3.PERMISSIONS.md)
4. Разработка реплик

---

Этот раздел описывает процесс создания новых реплик и контрактов для ReSide.

## Reside CLI

Reside CLI - это основной инструмент для управления кластерами ReSide и разработки реплик. Он позволяет:

- Создавать и удалять кластеры (`reside cluster bootstrap`, `reside cluster delete`);
- Управлять локальными аккаунтами Jazz (`reside account create`, `reside account list`);
- Загружать и управлять репликами (`reside replica load`, `reside replica list`);
- Запрашивать права администратора (`reside cluster claim-super-admin-access`);
- Собирать Docker-образы реплик и контрактов (`reside build`).

CLI автоматически обнаруживает кластеры в контекстах kubectl и сохраняет конфигурацию в `~/.config/reside/config.yaml`.

После создания кластера и получения прав администратора, CLI позволяет взаимодействовать с кластером напрямую через Jazz, минуя необходимость использования Kubernetes API или Telegram-бота для большинства административных задач.

## Создание нового контракта

Контракт определяет интерфейс взаимодействия между репликами. Каждый контракт находится в отдельном пакете в скоупе `@contracts/`.

### Структура контракта

Контракт определяется с помощью функции `defineContract` из пакета `@reside/shared`:

```typescript
export const MyContract = defineContract({
  identity: "ghcr.io/exeteres/reside/contracts/my-contract.v1",
  
  displayInfo: {
    ru: {
      title: "Мой контракт",
      description: "Описание контракта на русском",
    },
    en: {
      title: "My Contract",
      description: "Contract description in English",
    },
  },
  
  data: co.map({
    version: z.number().optional(),
    // поля данных контракта
  }),
  
  migration: async data => {
    // логика миграции данных при изменении схемы
  },
  
  methods: {
    // RPC-методы контракта
  },
  
  permissions: {
    // разрешения контракта
  },
})
```

### Поле identity

Identity контракта - это полное имя Docker-образа без тега. Оно должно:

- Быть уникальным в рамках всей экосистемы ReSide;
- Включать URL реестра и путь;
- Заканчиваться на версию контракта (например, `.v1`).

### Схема данных

Схема данных определяет, какие объекты Jazz будет хранить контракт:

```typescript
data: co.map({
  version: z.number().optional(),
  items: co.list(MyItem),
  config: typedJson<MyConfig>().optional(),
  group: co.group(),
})
```

Доступные типы:
- `co.list(Type)` - список объектов;
- `co.group()` - группа для управления доступом;
- `co.account()` - ссылка на аккаунт;
- `typedJson<T>()` - произвольные JSON-данные;
- Любые другие CoJSON типы из Jazz.

### Миграции

Миграции позволяют безопасно изменять схему данных при обновлении контракта:

```typescript
migration: async data => {
  const version = data.version ?? 0
  
  if (version < 1) {
    // инициализация новых полей
    data.$jazz.set("items", MyContract.data.shape.items.create([]))
  }
  
  if (version !== 1) {
    data.$jazz.set("version", 1)
  }
}
```

Миграции выполняются автоматически при первом обращении к данным контракта.

### RPC-методы

Методы позволяют репликам-потребителям вызывать функции у реплик-реализаторов:

```typescript
methods: {
  myMethod: {
    displayInfo: {
      ru: {
        title: "Мой метод",
        description: "Описание метода",
      },
    },
    
    definition: (url, workerId) => {
      return defineMethod({
        url,
        workerId,
        
        request: {
          param1: z.string(),
          param2: z.number(),
        },
        
        response: {
          schema: {
            result: MyResultType,
          },
          resolve: {
            result: true,
          },
        },
      })
    },
  },
}
```

### Разрешения

Разрешения определяют, какие доступы могут быть запрошены у реплики:

```typescript
permissions: {
  "item:read:all": {
    params: z.object(),
    
    displayInfo: {
      ru: {
        title: "Чтение всех элементов",
        description: "Позволяет читать все элементы в системе",
      },
    },
    
    onGranted: async (data, account) => {
      const loaded = await data.$jazz.ensureLoaded({ resolve: { items: true } })
      loaded.items.$jazz.owner.addMember(account, "reader")
    },
    
    onRevoked: async (data, account) => {
      const loaded = await data.$jazz.ensureLoaded({ resolve: { items: true } })
      loaded.items.$jazz.owner.removeMember(account)
    },
  },
  
  "item:create": {
    params: z.object({
      category: z.string(),
    }),
    
    getInstanceId: params => params.category,
    
    displayInfo: {
      ru: {
        title: "Создание элементов",
        description: "Позволяет создавать элементы в указанной категории",
      },
    },
  },
}
```

Разрешения с параметрами могут иметь несколько экземпляров, различающихся параметрами. Функция `getInstanceId` определяет уникальность экземпляра.

## Создание новой реплики

Реплика - это докер-образ с исполняемым кодом, реализующим один или несколько контрактов.

### Структура реплики

Реплика определяется с помощью функции `defineReplica`:

```typescript
export const MyReplica = defineReplica({
  identity: "ghcr.io/exeteres/reside/replicas/my-replica",
  
  info: {
    name: "my-replica",
    class: "long-running", // или "oneshot"
    exclusive: true,
    scalable: true,
  },
  
  displayInfo: {
    ru: {
      title: "Моя Реплика",
      description: "Описание реплики",
    },
  },
  
  implements: [MyContract],
  
  requires: [
    {
      contract: OtherContract,
      permissions: {
        "permission:name": {},
      },
    },
  ],
})
```

### Точка входа

Файл `src/main.ts` должен содержать вызов `startReplica`:

```typescript
import { startReplica } from "@reside/shared"
import { MyReplica } from "./replica"

const {
  replicaId,
  replicaName,
  account,
  implementations: { myContract },
  requirements: { otherContract },
  lockService,
  logger,
} = await startReplica(MyReplica)

// инициализация реплики
logger.info("replica started")

// регистрация обработчиков RPC-методов
myContract.handleMyMethod(async ({ param1, param2 }, madeBy) => {
  logger.info("method called by %s", madeBy.id)
  
  // проверка разрешений
  if (!myContract.checkPermission(madeBy, "permission:name")) {
    throw new JazzRequestError("Permission denied", 403)
  }
  
  // обработка запроса
  return { result: ... }
})
```

### Работа с данными контракта

Доступ к данным контракта осуществляется через `implementation.data`:

```typescript
const items = await myContract.data.$jazz.ensureLoaded({ resolve: { items: true } })

// добавление элемента
const newItem = MyItem.create({ name: "test" })
items.items.push(newItem)
```

### Использование транзакций

Для атомарных операций используйте `lockService.transaction`:

```typescript
await lockService.transaction(MyContract.data, myContract.data, async data => {
  // критическая секция, защищенная блокировкой
  // изменения в Jazz-объектах будут видны только после завершения транзакции
  const items = await data.$jazz.ensureLoaded({ resolve: { items: true } })
  items.items.push(newItem)
})
```

Транзакции автоматически захватывают распределенные блокировки через etcd на указанные Jazz-объекты и гарантируют, что одновременно только одна реплика может изменять их. Это критично для операций, требующих консистентности данных.

### Вызов методов других реплик

Используйте объекты из `requirements` для вызова методов:

```typescript
const result = await otherContract.someMethod({ param: "value" })
```

### Логирование

Используйте `logger` из контекста реплики:

```typescript
logger.info("message with %s", param)
logger.error({ err }, "error message")
logger.debug({ data }, "debug info")
```

Следуйте правилам из [`contributing/CODE_STYLE.md`](/contributing/CODE_STYLE.md) для форматирования логов.

## Паттерн Секретаря

Секретарь - это реплика, которая предоставляет пользовательский интерфейс для взаимодействия с другой репликой через Telegram. Примеры: [Секретарь Альфа-Реплики](/replicas/alpha-secretary/README.md) и [Секретарь Пользовательской Реплики](/replicas/user-manager-secretary/README.md).

### Принцип работы

Секретарь состоит из трех основных компонентов:

1. **Регистрация обработчика** - секретарь регистрирует обработчик в Телеграмной Реплике для получения сообщений от пользователей;
2. **Имперсонация** - секретарь использует разрешение `user:impersonate:realm:{realmName}` для выполнения действий от имени пользователей;
3. **Проксирование запросов** - секретарь вызывает методы целевой реплики с разрешениями имперсонированного пользователя.

### Преимущества паттерна

- **Безопасность**: секретарь не запрашивает широкие разрешения для себя, а использует разрешения конкретных пользователей;
- **Разделение ответственности**: логика бизнес-функций остается в целевой реплике, а секретарь только предоставляет UI;
- **Переиспользование**: один и тот же контракт можно использовать как через CLI, так и через Telegram, не дублируя логику проверки разрешений.

### Типичная структура секретаря

```typescript
const {
  requirements: { telegram, targetReplica, userManager }
} = await startReplica(SecretaryReplica)

const composer = new Composer<TelegramContext>()

composer.command("action", async ctx => {
  // имперсонация пользователя
  const impersonated = await userManager.impersonate(ctx.user)
  
  // вызов метода от имени пользователя
  const result = await targetReplica.someMethod({ 
    impersonatedAccount: impersonated 
  })
  
  // отображение результата
  await ctx.reply(formatResult(result))
})

await handler.init(telegram, telegramHandler, replicaName, composer, logger)
```

Секретарь не запрашивает широкие разрешения для себя, вместо этого он использует разрешения пользователей, что делает систему более безопасной. Подробнее о паттерне - в разделе [Паттерн Секретаря](/docs/2.REPLICAS.md#паттерн-секретаря) документации по репликам.

## Сборка и публикация

### Локальная сборка

Используйте Reside CLI для сборки образов. Запускайте команду из директории пакета реплики или контракта:

```bash
cd replicas/my-replica
reside build

# или с тегом
reside build --tag v1.0.0
```

### Публикация

Для публикации образа используйте флаг `--push`:

```bash
reside build --push
```

Это соберет образ и сразу отправит его в реестр.

### Загрузка в кластер

Используйте CLI для загрузки реплики:

```bash
reside replica load ghcr.io/exeteres/reside/replicas/my-replica:latest
```

## Тестирование

Реплики можно тестировать с помощью Jest или Bun Test:

```typescript
import { describe, test, expect } from "bun:test"
import { createMockAlphaData } from "@contracts/alpha.v1"

describe("MyReplica", () => {
  test("should process request correctly", async () => {
    const data = createMockAlphaData()
    // тестовая логика
  })
})
```

Используйте моки для контрактов, чтобы тестировать реплики изолированно.

## Рекомендации

1. **Следуйте CODE_STYLE.md** - все правила оформления кода строго соблюдаются;
2. **Минимизируйте разрешения** - запрашивайте только необходимые разрешения;
3. **Используйте транзакции** - для любых изменений, требующих консистентности;
4. **Логируйте ошибки** - все ошибки должны быть залогированы с контекстом;
5. **Документируйте контракты** - `displayInfo` должны быть понятными и полными;
6. **Версионируйте контракты** - при несовместимых изменениях создавайте новую версию.
