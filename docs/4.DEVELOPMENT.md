# Разработка реплик

1. [Обзор проекта](/docs/1.OVERVIEW.md)
2. [Реплики](/docs/2.REPLICAS.md)
3. [Система разрешений](/docs/3.PERMISSIONS.md)
4. Разработка реплик

---

Этот раздел описывает процесс создания новых реплик и контрактов для ReSide.

## Создание нового контракта

Контракт определяет интерфейс взаимодействия между репликами. Каждый контракт находится в отдельном пакете в скоупе `@contracts/`.

### Структура контракта

Контракт определяется с помощью функции `defineContract` из пакета `@reside/shared`:

```typescript
export const MyContract = defineContract({
  identity: "ghcr.io/exeteres/reside/contracts/my-contract.v1",
  
  displayInfo: {
    ru: {
      title: "Мой контракт",
      description: "Описание контракта на русском",
    },
    en: {
      title: "My Contract",
      description: "Contract description in English",
    },
  },
  
  data: co.map({
    version: z.number().optional(),
    // поля данных контракта
  }),
  
  migration: async data => {
    // логика миграции данных при изменении схемы
  },
  
  methods: {
    // RPC-методы контракта
  },
  
  permissions: {
    // разрешения контракта
  },
})
```

### Поле identity

Identity контракта - это полное имя Docker-образа без тега. Оно должно:

- Быть уникальным в рамках всей экосистемы ReSide;
- Включать URL реестра и путь;
- Заканчиваться на версию контракта (например, `.v1`).

### Схема данных

Схема данных определяет, какие объекты Jazz будет хранить контракт:

```typescript
data: co.map({
  version: z.number().optional(),
  items: co.list(MyItem),
  config: typedJson<MyConfig>().optional(),
  group: co.group(),
})
```

Доступные типы:
- `co.list(Type)` - список объектов;
- `co.group()` - группа для управления доступом;
- `co.account()` - ссылка на аккаунт;
- `typedJson<T>()` - произвольные JSON-данные;
- Любые другие CoJSON типы из Jazz.

### Миграции

Миграции позволяют безопасно изменять схему данных при обновлении контракта:

```typescript
migration: async data => {
  const version = data.version ?? 0
  
  if (version < 1) {
    // инициализация новых полей
    data.$jazz.set("items", MyContract.data.shape.items.create([]))
  }
  
  if (version !== 1) {
    data.$jazz.set("version", 1)
  }
}
```

Миграции выполняются автоматически при первом обращении к данным контракта.

### RPC-методы

Методы позволяют репликам-потребителям вызывать функции у реплик-реализаторов:

```typescript
methods: {
  myMethod: {
    displayInfo: {
      ru: {
        title: "Мой метод",
        description: "Описание метода",
      },
    },
    
    definition: (url, workerId) => {
      return defineMethod({
        url,
        workerId,
        
        request: {
          param1: z.string(),
          param2: z.number(),
        },
        
        response: {
          schema: {
            result: MyResultType,
          },
          resolve: {
            result: true,
          },
        },
      })
    },
  },
}
```

### Разрешения

Разрешения определяют, какие доступы могут быть запрошены у реплики:

```typescript
permissions: {
  "item:read:all": {
    params: z.object(),
    
    displayInfo: {
      ru: {
        title: "Чтение всех элементов",
        description: "Позволяет читать все элементы в системе",
      },
    },
    
    onGranted: async (data, account) => {
      const loaded = await data.$jazz.ensureLoaded({ resolve: { items: true } })
      loaded.items.$jazz.owner.addMember(account, "reader")
    },
    
    onRevoked: async (data, account) => {
      const loaded = await data.$jazz.ensureLoaded({ resolve: { items: true } })
      loaded.items.$jazz.owner.removeMember(account)
    },
  },
  
  "item:create": {
    params: z.object({
      category: z.string(),
    }),
    
    getInstanceId: params => params.category,
    
    displayInfo: {
      ru: {
        title: "Создание элементов",
        description: "Позволяет создавать элементы в указанной категории",
      },
    },
  },
}
```

Разрешения с параметрами могут иметь несколько экземпляров, различающихся параметрами. Функция `getInstanceId` определяет уникальность экземпляра.

## Создание новой реплики

Реплика - это докер-образ с исполняемым кодом, реализующим один или несколько контрактов.

### Структура реплики

Реплика определяется с помощью функции `defineReplica`:

```typescript
export const MyReplica = defineReplica({
  identity: "ghcr.io/exeteres/reside/replicas/my-replica",
  
  info: {
    name: "my-replica",
    class: "long-running", // или "oneshot"
    exclusive: true,
    scalable: true,
  },
  
  displayInfo: {
    ru: {
      title: "Моя Реплика",
      description: "Описание реплики",
    },
  },
  
  implements: [MyContract],
  
  requires: [
    {
      contract: OtherContract,
      permissions: {
        "permission:name": {},
      },
    },
  ],
})
```

### Точка входа

Файл `src/main.ts` должен содержать вызов `startReplica`:

```typescript
import { startReplica } from "@reside/shared"
import { MyReplica } from "./replica"

const {
  replicaId,
  replicaName,
  account,
  implementations: { myContract },
  requirements: { otherContract },
  lockService,
  logger,
} = await startReplica(MyReplica)

// инициализация реплики
logger.info("replica started")

// регистрация обработчиков RPC-методов
myContract.handleMyMethod(async ({ param1, param2 }, madeBy) => {
  logger.info("method called by %s", madeBy.id)
  
  // проверка разрешений
  if (!myContract.checkPermission(madeBy, "permission:name")) {
    throw new JazzRequestError("Permission denied", 403)
  }
  
  // обработка запроса
  return { result: ... }
})
```

### Работа с данными контракта

Доступ к данным контракта осуществляется через `implementation.data`:

```typescript
const items = await myContract.data.$jazz.ensureLoaded({ resolve: { items: true } })

// добавление элемента
const newItem = MyItem.create({ name: "test" })
items.items.push(newItem)
```

### Использование транзакций

Для атомарных операций используйте `lockService.transaction`:

```typescript
await lockService.transaction(MyContract.data, myContract.data, async data => {
  // критическая секция
  const items = await data.$jazz.ensureLoaded({ resolve: { items: true } })
  items.items.push(newItem)
})
```

Транзакции автоматически захватывают блокировки и гарантируют консистентность данных.

### Вызов методов других реплик

Используйте объекты из `requirements` для вызова методов:

```typescript
const result = await otherContract.someMethod({ param: "value" })
```

### Логирование

Используйте `logger` из контекста реплики:

```typescript
logger.info("message with %s", param)
logger.error({ err }, "error message")
logger.debug({ data }, "debug info")
```

Следуйте правилам из [`contributing/CODE_STYLE.md`](/contributing/CODE_STYLE.md) для форматирования логов.

## Паттерн Секретаря

Секретарь - это реплика, которая предоставляет пользовательский интерфейс для взаимодействия с другой репликой через Telegram.

Типичная структура секретаря:

1. Регистрирует обработчик в Телеграмной Реплике (`@contracts/telegram.v1`);
2. Использует имперсонацию для выполнения действий от имени пользователей;
3. Вызывает методы целевой реплики с разрешениями имперсонированного пользователя.

Пример из [Секретаря Альфа-Реплики](/replicas/alpha-secretary/src/main.ts):

```typescript
const { requirements: { telegram, alpha, userManager } } = await startReplica(SecretaryReplica)

const composer = new Composer<TelegramContext>()

composer.command("replicas", async ctx => {
  // имперсонация пользователя
  const impersonated = await userManager.impersonate(ctx.user)
  
  // вызов метода от имени пользователя
  const replicas = await alpha.listReplicas({ impersonatedAccount: impersonated })
  
  // отображение результата
  await ctx.reply(formatReplicas(replicas))
})

await handler.init(telegram, telegramHandler, replicaName, composer, logger)
```

Секретарь не запрашивает широкие разрешения для себя, вместо этого он использует разрешения пользователей, что делает систему более безопасной.

## Сборка и публикация

### Локальная сборка

Используйте Reside CLI для сборки образов:

```bash
reside build --replica my-replica
reside build --contract my-contract.v1
```

### Публикация

После сборки образы можно опубликовать в реестр:

```bash
docker push ghcr.io/exeteres/reside/replicas/my-replica:latest
docker push ghcr.io/exeteres/reside/contracts/my-contract.v1:latest
```

### Загрузка в кластер

Используйте CLI или Telegram-бота для загрузки реплики:

```bash
reside replica load ghcr.io/exeteres/reside/replicas/my-replica:latest
```

Или через Telegram:
```
/replicas → Загрузить реплику → Введите имя образа
```

## Тестирование

Реплики можно тестировать с помощью Jest или Bun Test:

```typescript
import { describe, test, expect } from "bun:test"
import { createMockAlphaData } from "@contracts/alpha.v1"

describe("MyReplica", () => {
  test("should process request correctly", async () => {
    const data = createMockAlphaData()
    // тестовая логика
  })
})
```

Используйте моки для контрактов, чтобы тестировать реплики изолированно.

## Рекомендации

1. **Следуйте CODE_STYLE.md** - все правила оформления кода строго соблюдаются;
2. **Минимизируйте разрешения** - запрашивайте только необходимые разрешения;
3. **Используйте транзакции** - для любых изменений, требующих консистентности;
4. **Логируйте ошибки** - все ошибки должны быть залогированы с контекстом;
5. **Документируйте контракты** - `displayInfo` должны быть понятными и полными;
6. **Версионируйте контракты** - при несовместимых изменениях создавайте новую версию.
